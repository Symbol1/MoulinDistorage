% !TEX encoding = UTF-8 Unicode
% !TEX TS-program = xelatex
% !TEX spellcheck = English
% !TEX pdfSinglePage

\makeatletter

\documentclass[aspectratio=1610]{beamer}
	\beamertemplatenavigationsymbolsempty
	\setbeamercovered{transparent=25}
	\setbeamersize{text margin left=3mm,text margin right=3mm}
	\def\CMH{\gdef\beamer@currentmode{handout}}
	\def\CMB{\gdef\beamer@currentmode{beamer}}
	\advance\parskip\fill
	\def\uncovert#1{\uncover<+->{\alert<.>{\ignorespaces#1}}}
	\def\recall#1{{\small Recall:#1}}
	
	\catcode`æ¿€13 \defæ¿€#1{\lccode`~`#1\lowercase{\catcode`#113\def~}}
	æ¿€è‰²#1!#2#3#4#5#6#7{\definecolor{#1}{HTML}{#2#3#4#5#6#7}}
	è‰²Illini Orange!FF552E  è‰²Altgeld!DD3403  è‰²Illini Blue!13294B
	è‰²Alma! 1E3877è‰²Industrial! 1D58A7è‰²Arches! 009FD4è‰²Cloud! F8FAFCè‰²Heritage! F5821E
	è‰²Alma2!4D69A0è‰²Industrial2!5783BCè‰²Arches2!7FC3E1è‰²Cloud2!E8E9EBè‰²Heritage2!E56E15
	è‰²Alma3!849BC1è‰²Industrial3!90AED5è‰²Arches3!A6D7EBè‰²Cloud3!DDDEDEè‰²Heritage3!CE5E11
	è‰²Alma4!AFC7DBè‰²Industrial4!CAD9EFè‰²Arches4!D2EBF5è‰²Cloud4!D2D2D2è‰²Heritage4!B74D04
	\setbeamercolor{normal text}{bg=Illini Blue,fg=Cloud}
	\setbeamercolor{structure}{fg=Illini Orange}
	\setbeamercolor{alerted text}{fg=Heritage}
	\setbeamercolor{example text}{fg=Altgeld}

\usepackage{xurl}
	\hypersetup{colorlinks,urlcolor=Arches}

\usepackage{mathtools,unicode-math}
	\setmainfont{Montserrat-Light}
	\setsansfont{Montserrat-Light}
	\setmonofont{Montserrat-Light}
	\setmathfont{texgyrepagella-math.otf}
	
	æ¿€ï¼ˆ{\bigl(} æ¿€ï¼‰{\bigr)}æ¿€ï¼»{\bigl[} æ¿€ï¼½{\bigr]} æ¿€ï½›{\bigl\{} æ¿€ï½{\bigr\}}
	æ¿€ï¼š{\colon} æ¿€â†¾{\bigr\upharpoonright} æ¿€â€ #1â€ {{\text{#1}}}
	\DeclareMathOperator\spa{span}
	\DeclareMathOperator\dom{dom}
	\DeclareMathOperator\im{im}
	\DeclareMathOperator\id{id}

\usepackage{tikz,tikz-cd}
	% https://tex.stackexchange.com/q/420034/
	\pgfmathdeclarefunction*{axis_height}0{\begingroup\pgfmathreturn.25em\endgroup}
	\pgfmathdeclarefunction*{rule_thickness}0{\begingroup\pgfmathreturn.06em\endgroup}
	\tikzset{
		every picture/.style={
			cap=round,join=round,line width=rule_thickness,
		},
		/pgf/arrow keys/glyph math command/.code={
			\pgfarrowsaddtooptions{\def\tikzcd@glyph{$\color{.}\csname #1\endcsname$}}
		},
		>/.tip={Glyph[glyph math command=rightarrow,glyph length=.32em]},
		>>/.tip={Glyph[glyph math command=twoheadrightarrow,glyph length=.49em]},
		c/.tip={Glyph[glyph math command=hookleftarrow, swap,glyph length=.28em]},
		% https://tex.stackexchange.com/q/55806/
		alt/.code args={<#1>#2#3}{\alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}}},
		cloud/.style={
			nodes={align=center,draw,outer sep=1ex},
			every edge/.style={draw,overlay,out=-90,in=90-30*(\h-4),->}
		},
		in/.code=\pgfmathsetmacro\tikz@to@in{#1}\tikz@to@switch@on,
		out/.code=\pgfmathsetmacro\tikz@to@out{#1}\tikz@to@switch@on,
	}
	\tikzcdset{
		every arrow/.style={/tikz/draw,->},
		skew/.style={
			row sep=1.5em,column sep=-1em,cells={xshift=-\pgfmatrixcurrentrow*2em}
		},
	}
	æ¿€ï¼†{}
	\newcommand\CD[2][]{\begin{tikzcd}[ampersand replacement=ï¼†,#1]#2\end{tikzcd}}
	æ¿€ç›´{
		\uar[xshift=.5em,<-c]\uar[xshift=-.5em,->>]
		\dar[xshift=.5em,->>]\dar[xshift=-.5em,<-c]
	}
	æ¿€æ–œ{
		\ar[start anchor={[xshift=1.5em]south},end anchor={[xshift=-1.5em]north}]
			{ddr}[pos=1/3]{âˆ‡}
	}
	æ¿€æ­ª<#1>{
		\ar[start anchor={[xshift=1.5em]south},end anchor={[xshift=-1.5em]north},
			alt=<#1>{alerted text.fg}{}]{ddr}[pos=1/3]{âˆ‡}
	}
	æ¿€ç©º<#1>{
		\ar[start anchor={[xshift=1.5em]south},end anchor={[xshift=4em]north east},
			alt=<#1>{alerted text.fg}{opacity=0},overlay]{dd}[pos=1/3]{âˆ‡}
	}
	æ¿€æ›²{
		\ar[start anchor=north,end anchor=south,xshift=1.5em,c->,overlay]{uu}
	}
	æ¿€ï¼¡{\alert}
	\def\alerrow#1{{
		\large#1\tikz[baseline=-axis_height]
		\draw(0,0)node[right,overlay,scale=4,alerted text.fg]{$â‡\strut$};}
	}

\usepackage{pgfplotstable,booktabs,colortbl}
	\pgfplotsset{compat/show suggested version=false,compat=1.18}
	\pgfplotstableset{
		every head row/.style={before row=\toprule,after row=\midrule},
		every last row/.style={after row=\bottomrule},string type,
	}
	\def\arraystretch{1.44}
	\pgfplotsinvokeforeach{1,...,7}{
		\tikzset{
			n#1/.pic={
				\draw[reset cm]({2*(#1-4)},{1/2*(-1)^#1})node(n#1){hard disk \##1};
			},
			N#1/.pic={
				\draw[reset cm]({2*(#1-4)},{1/2*(-1)^#1})node(N#1){size-$Î±$ disk \##1};
			}
		}
	}

\usepackage{qrcode}

\title{Moulin Coding}
\subtitle{A Multilinear-Algebraic Solution for Cloud Storage Services}
\author[H-P Wang]{Hsin-Po WANG\texorpdfstring\\{}\small(with Iwan Duursma and Xiao Li)}
\institute[UIUC]{Department of Mathematics, University of Illinois Urbana-Champaign}
\date[SIAM AG21]{2021-8-19 SIAM AG21}
\subject{cs.IT; 94B27, 68P20; 15A75}

\begin{document}

\def\linkfil#1{\vfil\vbox to#1cm{\hbox{.}\vfil\hbox to3mm{\hfil.}}}
\defbeamertemplate*{sidebar left}{thin-bold}{\pgfsetfillopacity0\vfilneg
	\hyperlinkframeendprev{\linkfil1}\hyperlinkslideprev{\linkfil3}
	\hyperlinkslidenext{\linkfil3}\hyperlinkframestartnext{\linkfil1}
	\pgfsetfillopacity1\vfilneg}

\frame{\vfill\maketitle}

\makeatletter
\tikzset{çŸ­/.pic={\node at(-.55,-.5)[rotate=-90,text width=\paperheight]{%
	\hfil\beamer@shortauthor\hfil\beamer@shorttitle\hfil\beamer@shortdate\hfil};}}
\defbeamertemplate*{sidebar right}{thin-bold}{\tikz[overlay,x=3mm,y=\paperheight]{
	\def\olfrac{\insertoverlaynumber/(\insertframeendpage+1-\insertframestartpage)}
	\path[save path=\æ¢¯,yscale={1/(\insertmainframenumber-1)}]
		(0,0)-|(-1,1-\insertframenumber)-|+({\olfrac},1)-|cycle;\footnotesize
	\pic[Alma4]{çŸ­};\fill[use path=\æ¢¯,Alma3];\clip[use path=\æ¢¯];\pic[Alma]{çŸ­};}}
\makeatother

\def\parti{Part I: Motivation from cloud storage services}
\def\partii{Part II: Construction of \emph{Moulin Codes}---special case}
\def\partiii{Part III: Construction of \emph{Moulin Codes}---general case}

\section{Outline}

\frame{{Outline}
	\uncovert{
		\parti
	}
	
	\uncovert{
		\partii
	}
	
	\uncovert{
		\partiii
	}
}

\frame{{Outline}
	\alerrow\parti
	
	\partii
	
	\partiii
}

\section{Motivation from cloud storage services}

\frame{{Motivation from cloud storage services}
	\vskip0ptplus-1fill
	$$\tikz[cloud]{
		\draw(0,-3)node(phi){\strut
			\only<-2>{a large file}%
			\only<3>{\phantom{a large file}}%
			\only<4>{recovered file}%
			\only<5>{happy customer =)}%
		};
		\foreach\h in{1,...,7}{
			\draw pic(){n\h};
			\draw<2>(n\h)edge[<-](phi);
			\draw<4>(n\h)edge(phi);
		}
	}$$
	
	\uncovert{
		A cloud storage service is a collection of hard disks that help you store big files.
	}
	
	\uncovert{
		Initially, you upload a big file to the cloud. Each hard disk will store part of the file.
	}
	
	\uncovert{
		You then delete the local copy to free up some space.
	}
	
	\uncovert{
		Later, when the file is needed, you download the file from the cloud.\\
		 Cloud company guarantees that it is exactly the same file as prevously uploaded.
	}
	
	\uncovert{
		From your point of view, it just works smoothly. But the cloud sees it differently.
	}
}

\section{What could go wrong behind the scene?}

\frame{{What could go wrong behind the scene?}
	\vskip0ptplus-1fill
	$$\tikz[cloud]{
		\draw(0,-3)node(phi){\strut
			\only<1,5-7>{\phantom{the same file}}%
			\only<2-4>{the same file}%
		};
		\draw[opacity=0]foreach\h in{1,...,7}{pic(){n\h}};
		\draw<1>foreach\h in{1,...,7}{pic{n\h}};
		\draw<2>foreach\h in{2,3,5,6,7}{pic{n\h}(n\h)edge(phi)};
		\draw<3>foreach\h in{1,2,3,4,7}{pic{n\h}(n\h)edge(phi)};
		\draw<4>foreach\h in{1,3,4,5,6}{pic{n\h}(n\h)edge(phi)};
		\draw<5>
			foreach\h in{1,2}{pic{n\h}(n\h)edge[in=-90-20*\h](n3)}
			foreach\h in{3}{pic[alerted text.fg]{n\h}}
			foreach\h in{4,5,6,7}{pic{n\h}(n\h)edge[in=-90+10*(8-\h)](n3)}
		;
		\draw<6>
			foreach\h in{1,2,3}{pic{n\h}(n\h)edge[in=-90-10*\h](n4)}
			foreach\h in{4}{pic[alerted text.fg]{n\h}}
			foreach\h in{5,6,7}{pic{n\h}(n\h)edge[in=-90+10*(8-\h)](n4)}
		;
		\draw<7>
			foreach\h in{1,...,6}{pic{n\h}(n\h)edge[in=-90-10*\h](n7)}
			foreach\h in{7}{pic[alerted text.fg]{n\h}}
		;
	}$$
	
	\uncovert{
		Difficulty A: Errors (mostly erasures) occur spontaneously. To ensure that\\
		errors do not corrupt your file, the cloud is equipped with error-correcting codes.
	}
	
	\uncovert{
		For instance, we may use a $[7,5,3]$-MDS code to protect the file, meaning that\\
		every set of $5$ disks contains sufficient information to recover the file.
	}
	\uncovert{Example 2}
	\uncovert{3}
	
	\uncovert{
		Difficulty B: Fixing errors costs money. Certainly we can recover the file from\\
		healthy disks and simulate the uploading phase. Can it be cheaper?
	}
	\uncovert{Example 2}
	\uncovert{3}
}

\section{Some notations and requirements of being a good cloud}

\frame{{Some notations and requirements of being a good cloud}
	\vskip0ptplus-1fill
	$$\tikz[cloud]{
		\draw(0,-3)node(phi){\strut
			\only<1-2>{$M$-symbol file}%
			\only<3>{\phantom{size-$M$ file}}%
		};
		\draw[opacity=0]foreach\h in{1,...,7}{pic(){N\h}};
		\draw<1>foreach\h in{1,...,7}{pic{N\h}};
		\draw<2>foreach\h in{2,3,5,6,7}{pic{N\h}(N\h)edge(phi)};
		\draw<3>[b/.style={auto,draw=none,inner sep=0}]
			foreach\h in{1,2}{pic{N\h}(N\h)edge[in=-90-10*\h]node[b,']{$Î²$}(N3)}
			foreach\h in{3}{pic[alerted text.fg]{N\h}}
			foreach\h in{4,5,6,7}{pic{N\h}(N\h)edge[in=-90+10*(8-\h)]node[b]{$Î²$}(N3)}
		;
	}$$
	
	\uncovert{
		The following notations are used in literature: The file consists of $M$ symbols.\\
		There are $n$ ($=7$) hard disks. Every disk stores $Î±$ symbols. ($Î±$ called \emph{disk capacity}).
	}
	
	\uncovert{
		Requirement A: Every set of $k$ ($=5$) disks suffices to recover the file.
	}
	
	\uncovert{
		Requirement B: Every set of $d$ ($=6$) disks can reconstruct, from scratch, one other\\
		disk by each sending out $Î²$ symbols of what it has. ($Î²$ is called \emph{repair bandwidth}.)
	}
}

\section{Designing cloud as a linear coding problem}

\frame{{Designing cloud as a linear coding problem}
	\uncovert{
		We can now formalize what a cloud should satisfy.
	}
	
	\uncovert{
		File size $M$ symbols $âŸ·$ File is a linear map $Ï†ï¼šğ”½^Mâ†’ğ”½$, for some finite field $ğ”½$.
	}
	
	\uncovert{
		$n$ disks, capacity $Î±$ $âŸ·$ the $h$th disk stores $Ï†â†¾_{X_h}$ for some subspace $ğ”½^Î±â‰…X_hâŠ†ğ”½^M$.
	}
	
	\uncovert{
		Any $k$ disks recover the file $âŸ·$ Any $k$ subspaces $X_{h_1},\dotsc,X_{h_k}$ span $Ï†$'s domain, $ğ”½^M$.
	}
	
	\uncovert{
		Any $d$ disks repair, bandwidth $Î²$ $âŸ·$ $âˆƒ$ subspaces $ğ”½^Î²â‰…Y_h^fâŠ†X_h$ s.t.\ $Y_{h_1}^f+\dotsb+Y_{h_d}^fâŠ‡X_f$.
	}
	
	\uncovert{
		One such tuple $(n,k,d,Î±,Î²,M;\{X_h\},\{Y_h^f\})$ is called a \emph{regenerating code}.
	}
	
	\uncovert{
		Sanity check: $kâ‰¤d<n$ (repairing is possible) and $dÎ²<M$ (repairing is nontrivial).
	}
}

\frame{{Outline}
	\parti
	
	\alerrow\partii
	
	\partiii
}

\section{Construct Moulin Code for special case k = d}

\frame{{Construct Moulin Code for special $k=d$}
	\recall{
		$n$ disks; $k$ recover the file; $d$ repair erased disks; $kâ‰¤d<n$, otherwise trivial.
	}
	
	\uncovert{
		Let $Wâ‰”ğ”½^k$. Consider the wedge-multiplication
		\begin{align*}
			WâŠ—Wâˆ§W	&	âŸ¶Wâˆ§Wâˆ§W,	\\
			xâŠ—yâˆ§z	&	âŸ¼xâˆ§yâˆ§z.	
		\end{align*}\\
	}
	
	\uncovert{
		It has a natural transpose/dual map, called co-wedge-multiplication
		\begin{align*}
			âˆ‡ï¼šWâˆ§Wâˆ§W		&	âŸ¶WâŠ—Wâˆ§W,				\\
			xâˆ§yâˆ§z		&	âŸ¼xâŠ—yâˆ§z-yâŠ—xâˆ§z+zâŠ—xâˆ§y.	
		\end{align*}\\
	}
	
	\uncovert{
		Let the file be any map $Ï†ï¼šWâŠ—Wâˆ§Wâ†’ğ”½$ such that $Ï†â†¾_{\imâˆ‡}=0$, meaning that\\
		it satisfies parity checks $0=Ï†(âˆ‡(xâˆ§yâˆ§z))=Ï†(xâŠ—yâˆ§z)-Ï†(yâŠ—xâˆ§z)+Ï†(zâŠ—xâˆ§y)$.
	}
}

\frame{{$k=d$ special case, page 2}
	\recall{
		$n$ disks; $k$ recover the file; $d$ repair erased disks. $Wâ‰”ğ”½^k$; and $Ï†â†¾_{\imâˆ‡}=0$.
	}
	
	\uncovert{
		Let the $n$ disks choose vectors $câ‚,câ‚‚,\dotsc,c_nâˆˆW$ that are MDS (i.e., any $k$ span $W$).\\
		Let the $h$th disk store the restriction $Ï†â†¾_{c_hâŠ—Wâˆ§W}$
	}
	
	\uncovert{
		Any $k$ disks recover $Ï†$: Let $ğ’¦$ be a set of $k$ indices, then by multilinearity \& MDSness,\\
		$âˆ‘_{hâˆˆğ’¦}c_hâŠ—Wâˆ§W=\spaâŸ¨c_h:hâˆˆğ’¦âŸ©âŠ—Wâˆ§W=WâŠ—Wâˆ§W=$ the entire domain of $Ï†$.
	}
	
	\uncovert{
		When the $f$th disk is erased, the $h$th disk sends it $Ï†â†¾_{c_hâŠ—c_fâˆ§W}$ to help repair.
	}
	
	\uncovert{
		Let $ğ’Ÿ$ be a set of $d$ indices, $âˆ‘_{hâˆˆğ’Ÿ}c_hâŠ—c_fâˆ§W=\spaâŸ¨c_h:hâˆˆğ’ŸâŸ©âŠ—c_fâˆ§W=WâŠ—c_fâˆ§W$.\\
		We repair $Ï†(c_fâŠ—yâˆ§z)=Ï†(yâŠ—c_fâˆ§z)-Ï†(zâŠ—c_fâˆ§y)$ as RHS is learned from $Ï†â†¾_{WâŠ—c_fâˆ§W}$
	}
}

\frame{{Outline}
	\parti
	
	\partii
	
	\alerrow\partiii
}

\section{Construct Moulin Code for general case k â‰¤ d}

\frame{{Construct Moulin Code for general case $kâ‰¤d$}
	\recall{
		$n$ disks; $k$ recover the file; $d$ repair erased disks. $Wâ‰”ğ”½^k$.
	}
	
	\uncovert{
		Let $Vâ‰”ğ”½^{d-k}$. Let $Uâ‰”VâŠ•W=ğ”½^d$. Consider the diagram:
	}
	\uncovert{
		$$\CD[skew]{
			Wâˆ§Wâˆ§Wæ­ª<4>	ï¼†	VâŠ—Wâˆ§Wæ­ª<5>	ï¼†	VâŠ—VâŠ—Wæ­ª<6>	ï¼†	VâŠ—VâŠ—Vç©º<7>	\\
						ï¼†	UâŠ—Wâˆ§Wç›´		ï¼†	VâŠ—UâŠ—Wç›´		ï¼†	VâŠ—VâŠ—Uç›´	\\
						ï¼†	WâŠ—Wâˆ§W		ï¼†	VâŠ—WâŠ—W		ï¼†	VâŠ—VâŠ—W	
		}$$
	}
	
	\uncovert{
		The file is a map $Ï†ï¼šâ€ direct sum of U-spacesâ€ â†’ğ”½$ that vanishes on $\im(\id-âˆ‡)$.\\
	}
	\uncovert{
		I.e., $0â‰•Ï†(xâˆ§yâˆ§z)=Ï†(xâŠ—yâˆ§z)-Ï†(yâŠ—xâˆ§z)+Ï†(zâŠ—xâˆ§y)$ where $x,y,zâˆˆW$\\
	}
	\uncovert{
		and $Ï†(xâŠ—yâˆ§z)=Ï†(xâŠ—yâŠ—z)-Ï†(xâŠ—zâŠ—y)$ where $xâˆˆV$ and $y,zâˆˆW$\\
	}
	\uncovert{
		and $Ï†(xâŠ—yâŠ—z)=Ï†(xâŠ—yâŠ—z)$ where $x,yâˆˆV$ and $zâˆˆW$ (not tautology but gluing)\\
	}
	\uncovert{
		and $Ï†(xâŠ—yâŠ—z)=Ï†(âˆ‡(xâŠ—yâŠ—z))â‰”0$ where $x,y,zâˆˆV$.
	}
}

\frame{{$kâ‰¤d$ general case, page 2}
	\recall{
		$n$ disks; $k$ recover the file; $d$ repair erased disks. $(U,V,W)â‰”(ğ”½^d,ğ”½^{d-k},ğ”½^k)$\\
		File $Ï†ï¼šâ¨â€ U-spacesâ€ â†’ğ”½$ is such that $Ï†(â€ tensorâ€ )=Ï†(âˆ‡(â€ tensorâ€ ))$.
	}
	
	\uncovert{
		Let the $n$ disks choose vectors $aâ‚,aâ‚‚,\dotsc,a_nâˆˆU$ that are MDS in the sense that\\
		(a) every $d$ of them span $U$; and (b) every $k$ of them span $U/W$ after projection.
	}
	
	\uncovert{
		Let the $h$th disk stores $Ï†â†¾_{a_hâŠ—Wâˆ§W+VâŠ—a_hâŠ—W+VâŠ—VâŠ—a_h}$ (i.e., replace $U$ by $a_h$).
	}
	
	\uncovert{
		Fix $k$ disks $ğ’¦$. Let $Xâ‰”\spaâŸ¨a_h:hâˆˆğ’¦âŸ©$. Then $V+X=U$. We learn restriction of $Ï†$ to
	}\\
	\uncover<.->{
		\alert<3,7,11>{this by parity check,}
		\alert<4,8,12>{this by downloading,}
		\alert<5,9,13>{this by MDS,}
		\alert<6,10>{this by projecting.}
	}
	\visible<14>{\alert<14>{Done!}}\\
	\uncover<3->{
		$$\CD[skew,row sep=1em,/tikz/row 4/.style={xshift=5em}]{
			Wâˆ§Wâˆ§Wæ–œ	ï¼†	ï¼¡<11>{VâŠ—Wâˆ§W}æ–œ	ï¼†	ï¼¡<7>{VâŠ—VâŠ—W}æ–œ	ï¼†	ï¼¡<3>{VâŠ—VâŠ—V}		\\
					ï¼†	ï¼¡<13>{UâŠ—Wâˆ§W}ç›´	ï¼†	ï¼¡<9>{VâŠ—UâŠ—W}ç›´	ï¼†	ï¼¡<5>{VâŠ—VâŠ—U}ç›´	\\
					ï¼†		{WâŠ—Wâˆ§W}	ï¼†	ï¼¡<10>{VâŠ—WâŠ—W}	ï¼†	ï¼¡<6>{VâŠ—VâŠ—W}		\\
					ï¼†	ï¼¡<12>{WâŠ—Wâˆ§X}æ›²	ï¼†	ï¼¡<8>{VâŠ—WâŠ—X}æ›²	ï¼†	ï¼¡<4>{VâŠ—VâŠ—X}æ›²	
		}$$
	}
}

\frame{{$kâ‰¤d$ general case, page 3}
	\recall{
		$(U,V,W)â‰”(ğ”½^d,ğ”½^{d-k},ğ”½^k)$. The $h$th disk stores $Ï†â†¾_{a_hâŠ—Wâˆ§W+VâŠ—a_hâŠ—W+VâŠ—VâŠ—a_h}$
	}
	
	\uncovert{
		When the $f$th disk is erased, let $a_fâ‰•(b_f,c_f)âˆˆVâŠ•W$ and send $Ï†â†¾_{\imâˆ‚}$, where
		\begin{align*}
			âˆ‚ï¼šVâŠ—U	&	âŸ¶VâŠ—VâŠ—U+VâŠ—UâŠ—W,				\\
			xâŠ—y		&	âŸ¼b_fâŠ—xâŠ—y-xâŠ—b_fâŠ—y+xâŠ—yâŠ—c_f,	\\
			âˆ‚ï¼šUâŠ—W	&	âŸ¶VâŠ—UâŠ—W+UâŠ—Wâˆ§W,				\\
			xâŠ—y		&	âŸ¼b_fâŠ—xâŠ—y-xâŠ—c_fâˆ§y.	
		\end{align*}\\
	}
	
	\uncovert{
		This weird definition is to satisfy the following two properties:
	}
	
	\uncovert{
		The definition of $âˆ‚$ extends to tensors of arbitrary length;\\
		it becomes a differential operator (a co-boundary operator) and is linear in $a_f$.
	}
	
	\uncovert{
		Let $Î½âˆˆT^pV$ and $Ï‰âˆˆÎ›^qW$, then $Ï†(âˆ‚(Î½âŠ—Ï‰))-Ï†(âˆ‚(âˆ‡(Î½âŠ—Ï‰)))=(-1)^pÏ†(Î½âŠ—a_fâŠ—Ï‰)$.\\
		LHS is learned from the helps from healthy nodes; RHS is the erased content.
	}
}

\section{Full generality Moulin Codes with larger diagram}

\frame{{Full generality Moulin Codes with larger diagram}
	\uncovert{\small
		$$\CD[skew,column sep=-4em]{
			Wâˆ§Wâˆ§Wâˆ§Wæ–œ	ï¼†	VâŠ—Wâˆ§Wâˆ§Wæ–œ	ï¼†	VâŠ—VâŠ—Wâˆ§Wæ–œ	ï¼†	VâŠ—VâŠ—VâŠ—Wæ–œ	ï¼†	VâŠ—VâŠ—VâŠ—V		\\
						ï¼†	UâŠ—Wâˆ§Wâˆ§Wç›´	ï¼†	VâŠ—UâŠ—Wâˆ§Wç›´	ï¼†	VâŠ—VâŠ—UâŠ—Wç›´	ï¼†	VâŠ—VâŠ—VâŠ—Uç›´	\\
						ï¼†	WâŠ—Wâˆ§Wâˆ§W		ï¼†	VâŠ—WâŠ—Wâˆ§W		ï¼†	VâŠ—VâŠ—WâŠ—W		ï¼†	VâŠ—VâŠ—VâŠ—W	
		}$$
	}
	
	\uncovert{
		$$\CD[skew]{
			T^{p-1}VâŠ—VâŠ—Î›^{q+1}Wæ–œ	ï¼†	T^pVâŠ—VâŠ—Î›^qWæ–œ	ï¼†						\\
									ï¼†	T^pVâŠ—UâŠ—Î›^qWç›´	ï¼†						\\
									ï¼†	T^pVâŠ—WâŠ—Î›^qW		ï¼†	T^{p+1}VâŠ—Wâˆ§Î›^{q-1}W	
		}$$
	}
}

\frame{{Full generality Moulin Codes, page 2}
	\vskip0ptplus-1fill
	\uncover<+->{
		\begin{align*}
			\alert<.>{âˆ‡(uâˆ§vâˆ§wâˆ§xâˆ§yâˆ§z)}	{}=\alert<.>{u}âŠ—vâˆ§wâˆ§xâˆ§yâˆ§z	\\
										{}-\alert<.>{v}âŠ—uâˆ§wâˆ§xâˆ§yâˆ§z	\\
										{}+\alert<.>{w}âŠ—uâˆ§vâˆ§xâˆ§yâˆ§z	\\
										{}-\alert<.>{x}âŠ—uâˆ§vâˆ§wâˆ§yâˆ§z	\\
										{}+\alert<.>{y}âŠ—uâˆ§vâˆ§wâˆ§xâˆ§z	\\
										{}-\alert<.>{z}âŠ—uâˆ§vâˆ§wâˆ§xâˆ§y	&	.
		\end{align*}\\[-1em]
	}
	\uncover<+->{
		\begin{align*}
			\alert<.>{âˆ‚(uâŠ—vâŠ—wâŠ—xâŠ—yâŠ—Î¶)}	{}=\alert<.>{b_f}âŠ—uâŠ—vâŠ—wâŠ—xâŠ—yâŠ—Î¶	\\
										{}-uâŠ—\alert<.>{b_f}âŠ—vâŠ—wâŠ—xâŠ—yâŠ—Î¶	\\
										{}+uâŠ—vâŠ—\alert<.>{b_f}âŠ—wâŠ—xâŠ—yâŠ—Î¶	\\
										{}-uâŠ—vâŠ—wâŠ—\alert<.>{b_f}âŠ—xâŠ—yâŠ—Î¶	\\
										{}+uâŠ—vâŠ—wâŠ—xâŠ—\alert<.>{b_f}âŠ—yâŠ—Î¶	\\
										{}+uâŠ—vâŠ—wâŠ—xâŠ—yâŠ—\alert<.>{c_f}âˆ§Î¶	&	.
		\end{align*}
	}
}

\section{The performance of regenerating code}

\frame{{The performance of regenerating code}
	\recall{
		$n$ disks; $k$ recover file; $d$ repair erasure; capacity $Î±$; bandwidth $Î²$; file size $M$.
	}
	
	\uncovert{
		Some reductions for ease of comparison: $(n,k,d)$ depends on actual applications.\\
		So papers on this subject usually fix $(n,k,d)$ and compare different codes' $(Î±,Î²,M)$.
	}
	
	\uncovert{
		Researchers usually start from $n=d+1$ and increase $n$ later,\\
		so it makes sense to ignore $n$ and parametrize the comparison by $(k,d)$.
	}
	
	\uncovert{
		It is also common to assume that the file is very very large, so\\
		$M$ can be pretty large and we only care about the long-term efficiency $(Î±/M,Î²/M)$.
	}
	
	\uncovert{
		In short, it is reasonable to plot all possible $(Î±/M,Î²/M)$ for each and every $(k,d)$.
	}
}

\section{The performance of Moulin Codes}

\frame{{The performance of Moulin Code}
	\vskip0ptplus-1fill
	$$\tikz{
		\def\p(####1,####2)/####3[####4]{
			(####1*100/####3,####2*100/####3)circle(.06em)
			node[below left,node contents={$(####1,####2)/####3[####4]$},anchor=50-10*####4]
		}
		\draw
			\p(32,16)/160[6]--
				\p(31,15)/154[5]--
					\p(26,11)/125[4]--
						\p(16,5)/70[3]--
							\p(6,1)/20[2];
		\def\xmin{20}\def\xmax{30}\def\ymax{10}\def\ymin{5}
		\draw
			(\xmin,\ymin-1)--(\xmax,\ymin-1)
			foreach\x in{\xmin,...,\xmax}{(\x,\ymin-1)--+(0,-1mm)node[below]{0.\x}}
			(\xmin-3,\ymin)--(\xmin-3,\ymax)
			foreach\y in{\ymin,...,\ymax}{(\xmin-3,\y)--+(-1mm,0)node[left]{0.\ifnum\y<10 0\fi\y}}
		;
	}$$
	\uncovert{
		Back to the opening example $(k,d)=(5,6)$. These are the achievable $(Î±/M,Î²/M)$.\\
	}
	\uncovert{
		The number in [square bracket] is the width of the diagram.
	}
}

\section{Open questions}

\frame{{Open questions}
	\uncovert{
		Is Moulin Codes' construction isomorphic to any (well-)known structure?
	}
	
	\uncovert{
		Are Moulin Codes optimal in terms of the $(Î±/M,Î²/M)$-plots?
	}
}

\frame{{Thank you, Questions}
	
	Beamer available at
	\tikz[baseline=(U.base)]\path[inner sep=0]
		node(U){\url{https://ag21.symbol.codes}}
		(U.north)+(0,.2)node[above]{\qrcode{https://ag21.symbol.codes}}
	;
	(so the links below are included).
	
	Paper version is titled \emph{Multilinear Algebra for Distributed Storage}, is available at\\
	\url{https://arxiv.org/abs/2006.08911}, and is accepted for publication in SIAM SIAGA.
	
	A similar work (that focuses on $M=kÎ±$ and uses symmetric algebra) is available at\\
	\url{https://arxiv.org/abs/2006.16998} and accepted for publication in Springer AAECC.
}

\appendix

\frame{{Why is it called Moulin Code?}
	\emph{Mu}ti\emph{lin}ear algebra.
	
	This code is inspired by another code called \emph{Cascade Code}.
	
	\emph{Cascade} is also a type of waterfall.
	
	\emph{Moulin} is another type of waterfall, the one that appears in glaciers.
	
	\emph{AWS Glacier} is a popular storage service.
}

\end{document}



